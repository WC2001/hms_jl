<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Configuration · HierarchicMemeticStrategy.jl</title><meta name="title" content="Configuration · HierarchicMemeticStrategy.jl"/><meta property="og:title" content="Configuration · HierarchicMemeticStrategy.jl"/><meta property="twitter:title" content="Configuration · HierarchicMemeticStrategy.jl"/><meta name="description" content="Documentation for HierarchicMemeticStrategy.jl."/><meta property="og:description" content="Documentation for HierarchicMemeticStrategy.jl."/><meta property="twitter:description" content="Documentation for HierarchicMemeticStrategy.jl."/><meta property="og:url" content="https://WC2001.github.io/HierarchicMemeticStrategy.jl/hms_config/"/><meta property="twitter:url" content="https://WC2001.github.io/HierarchicMemeticStrategy.jl/hms_config/"/><link rel="canonical" href="https://WC2001.github.io/HierarchicMemeticStrategy.jl/hms_config/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HierarchicMemeticStrategy.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Configuration</a><ul class="internal"><li><a class="tocitem" href="#HMS-Tree-Configuration"><span>HMS Tree Configuration</span></a></li><li><a class="tocitem" href="#HMS-Evolutionary-algorithms-used-in-metaepochs"><span>HMS Evolutionary algorithms used in metaepochs</span></a></li><li><a class="tocitem" href="#Stop-conditions"><span>Stop conditions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Configuration</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Configuration</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/main/docs/src/hms_config.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="HMS-Configuration"><a class="docs-heading-anchor" href="#HMS-Configuration">HMS Configuration</a><a id="HMS-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#HMS-Configuration" title="Permalink"></a></h1><p>HMS algorithm allows for customizing numerous configuration elements.</p><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.hms"><a class="docstring-binding" href="#HierarchicMemeticStrategy.hms"><code>HierarchicMemeticStrategy.hms</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hms(; kwargs...)</code></pre><p>Execute the Hierarchical Multi-Strategy (HMS) optimization algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>optimization_problem::OptimizationProblem</code>: The objective function and domain bounds.</li><li><code>level_config::Vector{TreeLevelConfig}</code>: Configuration for each level of the HMS tree (default: <code>DEFAULT_LEVEL_CONFIG</code>).</li><li><code>tree_height::Int</code>: Height of the HMS tree (default: <code>length(level_config)</code>).</li><li><code>sigma::Vector{Vector{Float64}}</code>: The $ \sigma $ parameter for evolutionary algorithms and Gaussian mutation. It is specified for each dimension at each level of the hierarchy.</li><li><code>gsc::GlobalStopCondition</code>: Condition to stop the entire optimization process.</li><li><code>lsc::LocalStopCondition</code>: Condition to stop individual demes.</li><li><code>sprout_condition::Function</code>: Logic determining when a deme should sprout a child deme.</li><li><code>population_sizes::Vector{Int}</code>: Number of individuals in demes at each level.</li><li><code>create_population::Function</code>: Function used to initialize deme populations.</li><li><code>local_optimizer::LocalOptimizer</code>: The specific local optimizer to use (default <code>LBFGSOptimizer</code>).</li><li><code>use_local_method::Bool</code>: Whether to apply a local optimization (default: <code>true</code>).</li><li><code>minimize::Bool</code>: Set to <code>true</code> to minimize, <code>false</code> to maximize (default: <code>true</code>).</li><li><code>log_level::Int</code>: Verbosity of the output (0 for silent, 1 basic output, 2 basic string representation of hms tree).</li><li><code>parallel::Bool</code>: Enable multi-threaded execution (default: <code>false</code>).</li><li><code>seed::Union{Nothing, Int}</code>: Random seed for reproducibility.</li></ul><p><strong>Returns</strong></p><ul><li><code>HMSResult</code>: An object containing the optimization trace, best solution, and visualization tools.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># optimizing eggholder function
function eggholder(x::Vector{Float64})
    x1, x2 = x[1], x[2]
    return -(x2 + 47) * sin(sqrt(abs(x2 + x1/2 + 47))) - x1 * sin(sqrt(abs(x1 - (x2 + 47))))
end

seed = 42
lower = [-512.0, -512.0]
upper = [512.0, 512.0]
problem = FunctionProblem(eggholder, lower, upper, false)
sigma = [[100.0, 100.0], [60.0, 60.0]]
level_config = [
    TreeLevelConfig(EvolutionaryGAMetaepoch, Dict(&quot;seed&quot; =&gt; seed)),
    TreeLevelConfig(EvolutionaryCMAESMetaepoch, Dict(&quot;seed&quot; =&gt; seed)),
]
result = hms(
    optimization_problem = problem,
    level_config = level_config,
    sigma=sigma,
    seed=seed 
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/HierarchicMemeticStrategy.jl#L63-L112">source</a></section></details></article><h2 id="HMS-Tree-Configuration"><a class="docs-heading-anchor" href="#HMS-Tree-Configuration">HMS Tree Configuration</a><a id="HMS-Tree-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#HMS-Tree-Configuration" title="Permalink"></a></h2><p>To define the evolutionary algorithms at different levels of the tree, use <code>TreeLevelConfig</code>.</p><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.TreeLevelConfig"><a class="docstring-binding" href="#HierarchicMemeticStrategy.TreeLevelConfig"><code>HierarchicMemeticStrategy.TreeLevelConfig</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TreeLevelConfig(metaepoch_type, options)</code></pre><p>Configuration for a specific level in the HMS hierarchy.</p><p><strong>Fields</strong></p><ul><li><code>metaepoch_type::Type{&lt;:MetaepochRunner}</code>: The evolutionary strategy or algorithm  to run at this level (e.g., <code>EvolutionaryGAMetaepoch</code> or <code>EvolutionaryCMAESMetaepoch</code>).</li><li><code>options::Dict{String, Any}</code>: A dictionary of hyperparameters specific to the chosen  <code>metaepoch_type</code> (e.g. crossover rates, mutation).</li></ul><p><strong>Usage</strong></p><p>Each level of the HMS tree can employ a different search strategy. By providing a  <code>Vector{TreeLevelConfig}</code> to the solver, you define how the search intensifies  from the root level down to the leaves.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">level_1 = TreeLevelConfig(EvolutionaryGAMetaepoch, Dict(&quot;crossoverRate&quot; =&gt; 0.3, &quot;mutationRate&quot; =&gt; 0.5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/config.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.DEFAULT_LEVEL_CONFIG"><a class="docstring-binding" href="#HierarchicMemeticStrategy.DEFAULT_LEVEL_CONFIG"><code>HierarchicMemeticStrategy.DEFAULT_LEVEL_CONFIG</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>DEFAULT<em>LEVEL</em>CONFIG</p><p>The default HMS tree structure used by the HMS solver if no custom configuration is provided.</p><p>It defines a 2-level tree:</p><p>Level 1: Uses EvolutionaryGAMetaepoch for broad exploration.</p><p>Level 2: Uses EvolutionaryCMAESMetaepoch for refined local search. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/config.jl#L36-L46">source</a></section></details></article><h2 id="HMS-Evolutionary-algorithms-used-in-metaepochs"><a class="docs-heading-anchor" href="#HMS-Evolutionary-algorithms-used-in-metaepochs">HMS Evolutionary algorithms used in metaepochs</a><a id="HMS-Evolutionary-algorithms-used-in-metaepochs-1"></a><a class="docs-heading-anchor-permalink" href="#HMS-Evolutionary-algorithms-used-in-metaepochs" title="Permalink"></a></h2><p>Here there are details for what evolutionary algorithms hms uses.</p><h3 id="MetaepochRunner-Interface"><a class="docs-heading-anchor" href="#MetaepochRunner-Interface">MetaepochRunner Interface</a><a id="MetaepochRunner-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#MetaepochRunner-Interface" title="Permalink"></a></h3><p>All metaepochs must implement simple MetaepochRunner interface.</p><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.MetaepochRunner"><a class="docstring-binding" href="#HierarchicMemeticStrategy.MetaepochRunner"><code>HierarchicMemeticStrategy.MetaepochRunner</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MetaepochRunner</code></pre><p>An abstract type serving as the interface for all HMS search strategies.</p><p><strong>Interface</strong></p><p>Any subtype of <code>MetaepochRunner</code> must implement the <code>run_metaepoch</code> function with the following signature:</p><pre><code class="language-julia hljs">run_metaepoch(
    runner::MetaepochRunner,
    fitness_function::Function,
    bounds::Bounds,
    initial_population::Vector{Vector{Float64}},
    minimize::Bool,
    options::Dict{String, Any}
)::MetaepochResult</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/metaepoch/metaepoch.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.MetaepochResult"><a class="docstring-binding" href="#HierarchicMemeticStrategy.MetaepochResult"><code>HierarchicMemeticStrategy.MetaepochResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MetaepochResult(solution, best_fitness, populations, fitness_values, context)</code></pre><p>A data structure that captures the outcome and trace of a single metaepoch execution.</p><p><strong>Fields</strong></p><ul><li><code>solution::Vector{Float64}</code>: The best input vector found during this metaepoch.</li><li><code>best_fitness::Float64</code>: The scalar fitness value associated with the <code>solution</code>.</li><li><code>populations::Vector{Vector{Vector{Float64}}}</code>: A history of populations. </li><li><code>fitness_values::Vector{Vector{Float64}}</code>: A history of fitness scores. </li></ul><p><strong>Description</strong></p><p>This object is returned by <code>run_metaepoch</code> and is used by the main HMS solver to  update the tree state, check stop conditions, and build the final result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/metaepoch/metaepoch.jl#L22-L36">source</a></section></details></article><p>At present, <code>HierarchicMemeticStrategy.jl</code> provides 3 different metaepochs: </p><ul><li><a href="#EvolutionaryGAMetaepoch"><code>EvolutionaryGAMetaepoch</code></a></li><li><a href="#EvolutionaryCMAESMetaepoch"><code>EvolutionaryCMAESMetaepoch</code></a></li><li><a href="#EvolutionaryDEMetaepoch"><code>EvolutionaryDEMetaepoch</code></a></li></ul><p>These metaepochs are built upon the robust implementations of <a href="https://wildart.github.io/Evolutionary.jl/stable/ga/">Genetic Algorithms (GA)</a>, <a href="https://wildart.github.io/Evolutionary.jl/stable/cmaes/">CMA-ES</a>, and <a href="https://wildart.github.io/Evolutionary.jl/stable/de/">Differential Evolution (DE)</a> provided by the <a href="https://github.com/wildart/Evolutionary.jl">Evolutionary.jl</a> package.</p><h3 id="EvolutionaryGAMetaepoch"><a class="docs-heading-anchor" href="#EvolutionaryGAMetaepoch">EvolutionaryGAMetaepoch</a><a id="EvolutionaryGAMetaepoch-1"></a><a class="docs-heading-anchor-permalink" href="#EvolutionaryGAMetaepoch" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.EvolutionaryGAMetaepoch"><a class="docstring-binding" href="#HierarchicMemeticStrategy.EvolutionaryGAMetaepoch"><code>HierarchicMemeticStrategy.EvolutionaryGAMetaepoch</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EvolutionaryGAMetaepoch &lt;: MetaepochRunner</code></pre><p>A metaepoch runner that utilizes a Genetic Algorithm (GA) implementation from the  <code>Evolutionary.jl</code> package.</p><p><strong>Description</strong></p><p>This runner performs a short burst of evolution on a deme&#39;s population. It is  typically used in the upper levels of the HMS tree for broad exploration of the  search space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/metaepoch/ga_metaepoch.jl#L53-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.run_metaepoch-Tuple{EvolutionaryGAMetaepoch, Function, Bounds, Vector{Vector{Float64}}, Bool, Dict{String, Any}}"><a class="docstring-binding" href="#HierarchicMemeticStrategy.run_metaepoch-Tuple{EvolutionaryGAMetaepoch, Function, Bounds, Vector{Vector{Float64}}, Bool, Dict{String, Any}}"><code>HierarchicMemeticStrategy.run_metaepoch</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run_metaepoch(::EvolutionaryGAMetaepoch, ...)</code></pre><p>Execute the Genetic Algorithm for a fixed number of iterations.</p><p><strong>Supported Options</strong></p><p>The <code>options::Dict{String, Any}</code> parameter in <code>TreeLevelConfig</code> supports the  following keys when using <code>EvolutionaryGAMetaepoch</code>:</p><table><tr><th style="text-align: left">Key</th><th style="text-align: left">Type</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>&quot;iterations&quot;</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>3</code></td><td style="text-align: left">Number of GA iterations to run.</td></tr><tr><td style="text-align: left"><code>&quot;crossoverRate&quot;</code></td><td style="text-align: left"><code>Float64</code></td><td style="text-align: left"><code>0.2</code></td><td style="text-align: left">Probability of crossover.</td></tr><tr><td style="text-align: left"><code>&quot;mutationRate&quot;</code></td><td style="text-align: left"><code>Float64</code></td><td style="text-align: left"><code>0.8</code></td><td style="text-align: left">Probability of mutation.</td></tr><tr><td style="text-align: left"><code>&quot;epsilon&quot;</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>1</code></td><td style="text-align: left">Number of best individuals to preserve (Elitism).</td></tr><tr><td style="text-align: left"><code>&quot;crossover&quot;</code></td><td style="text-align: left"><code>Function</code></td><td style="text-align: left"><code>LC()</code></td><td style="text-align: left">Crossover operator (from <code>Evolutionary.jl</code>).</td></tr><tr><td style="text-align: left"><code>&quot;mutation&quot;</code></td><td style="text-align: left"><code>Function</code></td><td style="text-align: left"><code>GaussianMutation</code></td><td style="text-align: left">Custom Gaussian mutation operator.</td></tr><tr><td style="text-align: left"><code>&quot;sigma&quot;</code></td><td style="text-align: left"><code>Vector</code></td><td style="text-align: left"><code>fill(1.0, N)</code></td><td style="text-align: left">Standard deviation for the default Gaussian mutation.</td></tr><tr><td style="text-align: left"><code>&quot;seed&quot;</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>nothing</code></td><td style="text-align: left">Local RNG seed for reproducibility.</td></tr><tr><td style="text-align: left"><code>&quot;show_trace&quot;</code></td><td style="text-align: left"><code>Bool</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">Whether to print <code>Evolutionary.jl</code> progress to console.</td></tr></table><p><strong>Details</strong></p><p>The fitness function is automatically transformed based on the <code>minimize</code> flag.  The population history is captured via a callback to ensure the <code>MetaepochResult</code>  trace is correctly populated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/metaepoch/ga_metaepoch.jl#L67-L92">source</a></section></details></article><h3 id="EvolutionaryCMAESMetaepoch"><a class="docs-heading-anchor" href="#EvolutionaryCMAESMetaepoch">EvolutionaryCMAESMetaepoch</a><a id="EvolutionaryCMAESMetaepoch-1"></a><a class="docs-heading-anchor-permalink" href="#EvolutionaryCMAESMetaepoch" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.run_metaepoch-Tuple{EvolutionaryCMAESMetaepoch, Function, Bounds, Vector{Vector{Float64}}, Bool, Dict{String, Any}}"><a class="docstring-binding" href="#HierarchicMemeticStrategy.run_metaepoch-Tuple{EvolutionaryCMAESMetaepoch, Function, Bounds, Vector{Vector{Float64}}, Bool, Dict{String, Any}}"><code>HierarchicMemeticStrategy.run_metaepoch</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run_metaepoch(::EvolutionaryCMAESMetaepoch, ...)</code></pre><p>Execute the Covariance Matrix Adaptation Evolution Strategy (CMA-ES) from the <code>Evolutionary.jl</code> package.</p><p><strong>Supported Options</strong></p><p>The <code>options::Dict{String, Any}</code> parameter in <code>TreeLevelConfig</code> supports the following keys when using <code>EvolutionaryCMAESMetaepoch</code>:</p><table><tr><th style="text-align: left">Key</th><th style="text-align: left">Type</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>&quot;iterations&quot;</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>3</code></td><td style="text-align: left">Number of CMA-ES iterations to run.</td></tr><tr><td style="text-align: left"><code>&quot;sigma0&quot;</code></td><td style="text-align: left"><code>Float64</code></td><td style="text-align: left">estimate_sigma0</td><td style="text-align: left">Initial step size.</td></tr><tr><td style="text-align: left"><code>&quot;seed&quot;</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>nothing</code></td><td style="text-align: left">Local RNG seed for reproducibility.</td></tr><tr><td style="text-align: left"><code>&quot;show_trace&quot;</code></td><td style="text-align: left"><code>Bool</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">Whether to print <code>Evolutionary.jl</code> progress to the console.</td></tr></table><p><strong>Details</strong></p><p>This method wraps the <code>CMAES</code> solver. It is particularly effective for  &quot;narrowing down&quot; on an optimum once the general area  has been found by a more exploratory algorithm like GA.</p><p>The population and fitness history are captured to populate the <code>MetaepochResult</code> trace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/metaepoch/cmaes_metaepoch.jl#L20-L41">source</a></section></details></article><h3 id="EvolutionaryDEMetaepoch"><a class="docs-heading-anchor" href="#EvolutionaryDEMetaepoch">EvolutionaryDEMetaepoch</a><a id="EvolutionaryDEMetaepoch-1"></a><a class="docs-heading-anchor-permalink" href="#EvolutionaryDEMetaepoch" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.run_metaepoch-Tuple{EvolutionaryDEMetaepoch, Function, Bounds, Vector{Vector{Float64}}, Bool, Dict{String, Any}}"><a class="docstring-binding" href="#HierarchicMemeticStrategy.run_metaepoch-Tuple{EvolutionaryDEMetaepoch, Function, Bounds, Vector{Vector{Float64}}, Bool, Dict{String, Any}}"><code>HierarchicMemeticStrategy.run_metaepoch</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run_metaepoch(::EvolutionaryDEMetaepoch, ...)</code></pre><p>Execute the Differential Evolution (DE) algorithm implementation from the <code>Evolutionary.jl</code> package.</p><p><strong>Supported Options</strong></p><p>The <code>options::Dict{String, Any}</code> parameter in <code>TreeLevelConfig</code> supports the following keys when using <code>EvolutionaryDEMetaepoch</code>:</p><table><tr><th style="text-align: left">Key</th><th style="text-align: left">Type</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>&quot;iterations&quot;</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>3</code></td><td style="text-align: left">Number of DE iterations to run.</td></tr><tr><td style="text-align: left"><code>&quot;F&quot;</code></td><td style="text-align: left"><code>Float64</code></td><td style="text-align: left"><code>0.9</code></td><td style="text-align: left">Scale factor (differential weight) for mutation.</td></tr><tr><td style="text-align: left"><code>&quot;n&quot;</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>1</code></td><td style="text-align: left">Number of differences used in the perturbation.</td></tr><tr><td style="text-align: left"><code>&quot;selection&quot;</code></td><td style="text-align: left"><code>Function</code></td><td style="text-align: left"><code>random</code></td><td style="text-align: left">Selection strategy (e.g., <code>random</code> or <code>best</code>).</td></tr><tr><td style="text-align: left"><code>&quot;recombination&quot;</code></td><td style="text-align: left"><code>Function</code></td><td style="text-align: left"><code>BINX(0.5)</code></td><td style="text-align: left">Recombination operator (e.g., <code>BINX</code> or <code>EXP</code>).</td></tr><tr><td style="text-align: left"><code>&quot;K&quot;</code></td><td style="text-align: left"><code>Float64</code></td><td style="text-align: left"><code>0.5*(F+1)</code></td><td style="text-align: left">Recombination constant.</td></tr><tr><td style="text-align: left"><code>&quot;seed&quot;</code></td><td style="text-align: left"><code>Int</code></td><td style="text-align: left"><code>nothing</code></td><td style="text-align: left">Local RNG seed for reproducibility.</td></tr><tr><td style="text-align: left"><code>&quot;show_trace&quot;</code></td><td style="text-align: left"><code>Bool</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">Whether to print <code>Evolutionary.jl</code> progress to the console.</td></tr></table><p><strong>Details</strong></p><p>This method wraps the <code>DE</code> solver from <code>Evolutionary.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/metaepoch/de_metaepoch.jl#L20-L41">source</a></section></details></article><h2 id="Stop-conditions"><a class="docs-heading-anchor" href="#Stop-conditions">Stop conditions</a><a id="Stop-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Stop-conditions" title="Permalink"></a></h2><p>Stop conditions are configurable hms parameters. They are used to control the process.</p><h3 id="Global-stop-condition"><a class="docs-heading-anchor" href="#Global-stop-condition">Global stop condition</a><a id="Global-stop-condition-1"></a><a class="docs-heading-anchor-permalink" href="#Global-stop-condition" title="Permalink"></a></h3><p>The Global Stop Condition (GSC) defines the termination criteria for the entire HMS algorithm, such as reaching a maximum number of function evaluations. It ensures the overall search process concludes once the primary optimization goals or resource limits are met.</p><h4 id="Available-Global-Stop-Conditions"><a class="docs-heading-anchor" href="#Available-Global-Stop-Conditions">Available Global Stop Conditions</a><a id="Available-Global-Stop-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Global-Stop-Conditions" title="Permalink"></a></h4><p>The following conditions can be passed to the hms solver to control the total execution:</p><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.ProblemEvaluationLimitReached"><a class="docstring-binding" href="#HierarchicMemeticStrategy.ProblemEvaluationLimitReached"><code>HierarchicMemeticStrategy.ProblemEvaluationLimitReached</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ProblemEvaluationLimitReached(limit::Int)</code></pre><p>A <code>GlobalStopCondition</code> that terminates the optimization once a specific number of  objective function evaluations has been reached.</p><p><strong>Fields</strong></p><ul><li><code>limit::Int</code>: The maximum allowed number of function evaluations (must be positive).</li></ul><p><strong>Description</strong></p><p>This is the most common stopping criterion for the HMS algorithm. It monitors the  global evaluation counter and returns <code>true</code> as soon as the total evaluations  exceed the specified <code>limit</code>, ensuring the algorithm respects a predefined  computational budget.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Stop the algorithm after 10,000 function evaluations
gsc = ProblemEvaluationLimitReached(10000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/stop_conditions/global_stop_condition.jl#L36-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.GlobalMetaepochLimitReached"><a class="docstring-binding" href="#HierarchicMemeticStrategy.GlobalMetaepochLimitReached"><code>HierarchicMemeticStrategy.GlobalMetaepochLimitReached</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GlobalMetaepochLimitReached(limit::Int)</code></pre><p>A <code>GlobalStopCondition</code> that terminates the optimization after a fixed number of metaepochs.</p><p><strong>Fields</strong></p><ul><li><code>limit::Int</code>: The maximum number of metaepochs to perform (must be positive).</li></ul><p><strong>Description</strong></p><p>In HMS metaepoch represents one full iteration of the algorithm where  every active deme in the tree is processed.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Stop the algorithm after 50 metaepochs of the HMS tree
gsc = GlobalMetaepochLimitReached(50)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/stop_conditions/global_stop_condition.jl#L3-L20">source</a></section></details></article><h4 id="Default-GSC"><a class="docs-heading-anchor" href="#Default-GSC">Default GSC</a><a id="Default-GSC-1"></a><a class="docs-heading-anchor-permalink" href="#Default-GSC" title="Permalink"></a></h4><p>The default GSC is set to ProblemEvaluationLimitReached with 10000 fitness function evaluation limit.</p><pre><code class="language-julia hljs">GSC = ProblemEvaluationLimitReached(10000)</code></pre><h3 id="Local-stop-condition"><a class="docs-heading-anchor" href="#Local-stop-condition">Local stop condition</a><a id="Local-stop-condition-1"></a><a class="docs-heading-anchor-permalink" href="#Local-stop-condition" title="Permalink"></a></h3><p>The Local Stop Condition (LSC) determines when an individual deme should stop its local search. This allows the HMS tree to dynamically reallocate resources by pruning stagnant demes and sprouting new ones in more promising areas.</p><h4 id="Available-Local-Stop-Conditions"><a class="docs-heading-anchor" href="#Available-Local-Stop-Conditions">Available Local Stop Conditions</a><a id="Available-Local-Stop-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Local-Stop-Conditions" title="Permalink"></a></h4><p>The following conditions can be passed to the hms solver to control the demes:</p><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.LocalProblemEvaluationLimitReached"><a class="docstring-binding" href="#HierarchicMemeticStrategy.LocalProblemEvaluationLimitReached"><code>HierarchicMemeticStrategy.LocalProblemEvaluationLimitReached</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LocalProblemEvaluationLimitReached(limit::Int)</code></pre><p>A <code>LocalStopCondition</code> that terminates a specific deme once it has performed a  certain number of objective function evaluations.</p><p><strong>Fields</strong></p><ul><li><code>limit::Int</code>: The maximum number of evaluations allowed for the specific deme.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Limit each leaf deme to 1000 evaluations
lsc = LocalProblemEvaluationLimitReached(1000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/stop_conditions/local_stop_condition.jl#L21-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.AllChildrenStopped"><a class="docstring-binding" href="#HierarchicMemeticStrategy.AllChildrenStopped"><code>HierarchicMemeticStrategy.AllChildrenStopped</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AllChildrenStopped()</code></pre><p>A <code>LocalStopCondition</code> that triggers only when all children of the current deme  have reached their own stopping criteria.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/stop_conditions/local_stop_condition.jl#L49-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.MetaepochWithoutBestFitnessImprovement"><a class="docstring-binding" href="#HierarchicMemeticStrategy.MetaepochWithoutBestFitnessImprovement"><code>HierarchicMemeticStrategy.MetaepochWithoutBestFitnessImprovement</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MetaepochWithoutBestFitnessImprovement(n_metaepochs::Int)</code></pre><p>A <code>LocalStopCondition</code> that triggers if the best fitness within a deme fails to  improve for a specified number of consecutive metaepochs.</p><p><strong>Fields</strong></p><ul><li><code>n_metaepochs::Int</code>: The threshold of consecutive stagnant metaepochs allowed before stopping.</li></ul><p><strong>Description</strong></p><p>This condition is used to prune demes that have reached a local optimum or are  stuck in a plateau.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Stop a deme if it doesn&#39;t improve for 5 consecutive metaepochs
lsc = MetaepochWithoutBestFitnessImprovement(5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/stop_conditions/local_stop_condition.jl#L71-L89">source</a></section></details></article><h4 id="Default-LSC"><a class="docs-heading-anchor" href="#Default-LSC">Default LSC</a><a id="Default-LSC-1"></a><a class="docs-heading-anchor-permalink" href="#Default-LSC" title="Permalink"></a></h4><p>The default LSC is set to MetaepochWithoutBestFitnessImprovement with 10 metaepochs  without improvement limit.</p><pre><code class="language-julia hljs">DEFAULT_LSC = MetaepochWithoutBestFitnessImprovement(10)</code></pre><h3 id="Sprout-condition"><a class="docs-heading-anchor" href="#Sprout-condition">Sprout condition</a><a id="Sprout-condition-1"></a><a class="docs-heading-anchor-permalink" href="#Sprout-condition" title="Permalink"></a></h3><p>Configurable parameter determining when a deme should sprout a child deme.</p><p><code>HierarchicMemeticStrategy.jl</code> provides sprout condition based on euclidean distance between demes.</p><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.sc_max_metric"><a class="docstring-binding" href="#HierarchicMemeticStrategy.sc_max_metric"><code>HierarchicMemeticStrategy.sc_max_metric</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sc_max_metric(metric::Function, max_distances::Vector{Float64})</code></pre><p>Create a sprouting condition that ensures a new deme is sufficiently far from existing demes at the same level.</p><p><strong>Arguments</strong></p><ul><li><code>metric::Function</code>: A distance function, e.g., <code>dist(a, b)</code>, used to calculate the separation between points.</li><li><code>max_distances::Vector{Float64}</code>: A vector where <code>max_distances[i]</code> defines the minimum required distance for level <code>i + 1</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A function <code>(potential_sprout, potential_sprout_level, demes) -&gt; Bool</code> that returns <code>true</code> if the potential sprout location is valid.</li></ul><p><strong>Description</strong></p><p>If the distance to <strong>any</strong> existing deme at that level is less than the threshold defined in <code>max_distances</code>, the condition returns <code>false</code>, and the sprout is suppressed. This mechanism is critical for:</p><ol><li><strong>Diversity</strong>: Preventing multiple demes from converging on the same local optimum.</li><li><strong>Exploration</strong>: Forcing the algorithm to seek out new, unexplored regions of the search space.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Use Euclidean distance with a 2.0 threshold for level 2 and 0.5 for level 3
euclidean(a::Vector{Float64}, b::Vector{Float64}) = sqrt(sum((a .- b).^2))
sprout_cond = sc_max_metric(euclidean, [2.0, 0.5])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/sprout_condition.jl#L9-L32">source</a></section></details></article><h4 id="Default-Sprout-Condition"><a class="docs-heading-anchor" href="#Default-Sprout-Condition">Default Sprout Condition</a><a id="Default-Sprout-Condition-1"></a><a class="docs-heading-anchor-permalink" href="#Default-Sprout-Condition" title="Permalink"></a></h4><p>The default SC uses euclidean distance with default max distances calculated based on sigma parameter.</p><pre><code class="language-julia hljs">function sprout_default_euclidean_distances(sigma::Vector{Vector{Float64}})
    sprouting_condition_distance_ratio = 0.6
    return [sum(s .* sprouting_condition_distance_ratio) for s in sigma]
end

const DEFAULT_SC = function (sigma::Vector{Vector{Float64}})
    return sc_max_metric(euclidean, sprout_default_euclidean_distances(sigma))   
end</code></pre><h3 id="Sigma"><a class="docs-heading-anchor" href="#Sigma">Sigma</a><a id="Sigma-1"></a><a class="docs-heading-anchor-permalink" href="#Sigma" title="Permalink"></a></h3><p>Parameter for evolutionary algorithms and Gaussian mutation.  It is specified for each dimension at each level of the hms tree.</p><h4 id="Default-sigma"><a class="docs-heading-anchor" href="#Default-sigma">Default sigma</a><a id="Default-sigma-1"></a><a class="docs-heading-anchor-permalink" href="#Default-sigma" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.default_sigma"><a class="docstring-binding" href="#HierarchicMemeticStrategy.default_sigma"><code>HierarchicMemeticStrategy.default_sigma</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_sigma(lower::Vector{Float64}, upper::Vector{Float64}, tree_height::Int)</code></pre><p>Generate sigma parameter for each level of the HMS tree.</p><p><strong>Arguments</strong></p><ul><li><code>lower::Vector{Float64}</code>: Lower bounds of the search space.</li><li><code>upper::Vector{Float64}</code>: Upper bounds of the search space.</li><li><code>tree_height::Int</code>: Total number of levels in the HMS hierarchy.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector{Float64}}</code>: A list of sigma vectors, one for each level, where values decrease geometrically as the tree gets deeper.</li></ul><p><strong>Description</strong></p><p>Sigma value is a fraction of the total domain length (<code>upper - lower</code>). This function  applies a geometric decay:</p><ul><li><strong>Root Level</strong>: Starts at 4% of the domain length (<code>sigma_ratio = 0.04</code>).</li><li><strong>Subsequent Levels</strong>: Each level&#39;s sigma is reduced by 50% (<code>sigma_exponent = 0.5</code>) compared to the level above.</li></ul><p>This ensures that top-level demes perform broad global exploration, while lower-level demes focus on increasingly fine-grained local exploitation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/config.jl#L116-L136">source</a></section></details></article><h3 id="Population-sizes"><a class="docs-heading-anchor" href="#Population-sizes">Population sizes</a><a id="Population-sizes-1"></a><a class="docs-heading-anchor-permalink" href="#Population-sizes" title="Permalink"></a></h3><p>Parameter specifies number of individuals in demes at each level.</p><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.default_population_sizes"><a class="docstring-binding" href="#HierarchicMemeticStrategy.default_population_sizes"><code>HierarchicMemeticStrategy.default_population_sizes</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_population_sizes(tree_height::Int)</code></pre><p>Generate set of population sizes for each level of the HMS tree.</p><p><strong>Arguments</strong></p><ul><li><code>tree_height::Int</code>: Total number of levels in the HMS hierarchy.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: A vector of population sizes, one for each level, decreasing as the tree gets deeper.</li></ul><p><strong>Description</strong></p><p>In a Hierarchical Multi-Strategy search, it is often beneficial to have larger populations  at the root level to maintain diversity and smaller populations at lower levels for  specialized local search. This function implements a geometric decay:</p><ul><li><strong>Root Level</strong>: Starts with a population of 60.</li><li><strong>Decay</strong>: Each subsequent level&#39;s population is reduced by 50%.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sizes = default_population_sizes(4)
# Returns: [60, 30, 15, 8]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/config.jl#L78-L101">source</a></section></details></article><h3 id="Create-population-function"><a class="docs-heading-anchor" href="#Create-population-function">Create population function</a><a id="Create-population-function-1"></a><a class="docs-heading-anchor-permalink" href="#Create-population-function" title="Permalink"></a></h3><p>Configurable parameter that specifies how new populations are created.</p><h4 id="Default-create-population"><a class="docs-heading-anchor" href="#Default-create-population">Default create population</a><a id="Default-create-population-1"></a><a class="docs-heading-anchor-permalink" href="#Default-create-population" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.default_create_population"><a class="docstring-binding" href="#HierarchicMemeticStrategy.default_create_population"><code>HierarchicMemeticStrategy.default_create_population</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_create_population(sigma::Vector{Vector{Float64}}, rng::AbstractRNG = Random.default_rng())</code></pre><p>Create a population initialization that chooses between uniform and normal distributions based on tree level.</p><p><strong>Arguments</strong></p><ul><li><code>sigma::Vector{Vector{Float64}}</code>: A vector of step-size vectors for each level (e.g., from <code>default_sigma</code>).</li><li><code>rng::AbstractRNG</code>: An optional random number generator for reproducibility.</li></ul><p><strong>Returns</strong></p><ul><li>A function <code>(mean, lower, upper, population_size, tree_level, sigma, rng) -&gt; Vector{Vector{Float64}}</code>.</li></ul><p><strong>Description</strong></p><p>The returned function handles two distinct initialization strategies:</p><ol><li><strong>Root Level (Level 1)</strong>: Uses uniform distribution. This ensures the initial search covers the entire search space defined by <code>lower</code> and <code>upper</code>.</li><li><strong>Subsequent Levels (Level &gt; 1)</strong>: Uses uses normal distribution centered around the <code>mean</code> (new deme). The spread is controlled by the <code>sigma</code> corresponding to tree level.</li></ol><p>This approach is fundamental to HMS: the root explores globally, while children refine locally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/deme/deme.jl#L136-L155">source</a></section></details></article><h3 id="Local-optimizer"><a class="docs-heading-anchor" href="#Local-optimizer">Local optimizer</a><a id="Local-optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#Local-optimizer" title="Permalink"></a></h3><p>Parameter sets local optimizer to perform search from best individuals at leaf demes  after global stop condition is satisfied. </p><article><details class="docstring" open="true"><summary id="HierarchicMemeticStrategy.LocalOptimizer"><a class="docstring-binding" href="#HierarchicMemeticStrategy.LocalOptimizer"><code>HierarchicMemeticStrategy.LocalOptimizer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LocalOptimizer</code></pre><p>An abstract type for all local refinement strategies in the HMS algorithm.</p><p><strong>Description</strong></p><p><code>LocalOptimizer</code> is used to perform fine-grained refinement on the  best individual of a leaf demes after global stop condition is satisfied.</p><p><strong>Interface</strong></p><p>Any subtype must implement: <code>optimize!(optimizer::LocalOptimizer, deme::Deme, cached_f::CustomCache)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WC2001/HierarchicMemeticStrategy.jl/blob/8fa813424a7b39819e74d2ece34b59fcb93efb85/src/local_method/local_optimizer.jl#L1-L13">source</a></section></details></article><h4 id="Default-local-optimizer"><a class="docs-heading-anchor" href="#Default-local-optimizer">Default local optimizer</a><a id="Default-local-optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#Default-local-optimizer" title="Permalink"></a></h4><p>Default local optimizer uses <strong><a href="https://julianlsolvers.github.io/Optim.jl/stable/#algo/lbfgs/">L-BFGS</a></strong> implementation from the <strong><a href="https://julianlsolvers.github.io/Optim.jl/stable/">Optim.jl</a></strong> package.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 7 January 2026 09:55">Wednesday 7 January 2026</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
