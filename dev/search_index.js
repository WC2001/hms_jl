var documenterSearchIndex = {"docs":
[{"location":"hms_config/#HMS-Configuration","page":"Configuration","title":"HMS Configuration","text":"HMS algorithm allows for customizing numerous configuration elements.","category":"section"},{"location":"hms_config/#HMS-Tree-Configuration","page":"Configuration","title":"HMS Tree Configuration","text":"To define the evolutionary algorithms at different levels of the tree, use TreeLevelConfig.","category":"section"},{"location":"hms_config/#HMS-Evolutionary-algorithms-used-in-metaepochs","page":"Configuration","title":"HMS Evolutionary algorithms used in metaepochs","text":"Here there are details for what evolutionary algorithms hms uses.","category":"section"},{"location":"hms_config/#MetaepochRunner-Interface","page":"Configuration","title":"MetaepochRunner Interface","text":"All metaepochs must implement simple MetaepochRunner interface.\n\nAt present, HierarchicMemeticStrategy.jl provides 3 different metaepochs: \n\nEvolutionaryGAMetaepoch\nEvolutionaryCMAESMetaepoch\nEvolutionaryDEMetaepoch\n\nThese metaepochs are built upon the robust implementations of Genetic Algorithms (GA), CMA-ES, and Differential Evolution (DE) provided by the Evolutionary.jl package.","category":"section"},{"location":"hms_config/#EvolutionaryGAMetaepoch","page":"Configuration","title":"EvolutionaryGAMetaepoch","text":"","category":"section"},{"location":"hms_config/#EvolutionaryCMAESMetaepoch","page":"Configuration","title":"EvolutionaryCMAESMetaepoch","text":"","category":"section"},{"location":"hms_config/#EvolutionaryDEMetaepoch","page":"Configuration","title":"EvolutionaryDEMetaepoch","text":"","category":"section"},{"location":"hms_config/#Stop-conditions","page":"Configuration","title":"Stop conditions","text":"Stop conditions are configurable hms parameters. They are used to control the process.","category":"section"},{"location":"hms_config/#Global-stop-condition","page":"Configuration","title":"Global stop condition","text":"The Global Stop Condition (GSC) defines the termination criteria for the entire HMS algorithm, such as reaching a maximum number of function evaluations. It ensures the overall search process concludes once the primary optimization goals or resource limits are met.","category":"section"},{"location":"hms_config/#Available-Global-Stop-Conditions","page":"Configuration","title":"Available Global Stop Conditions","text":"The following conditions can be passed to the hms solver to control the total execution:","category":"section"},{"location":"hms_config/#Default-GSC","page":"Configuration","title":"Default GSC","text":"The default GSC is set to ProblemEvaluationLimitReached with 10000 fitness function evaluation limit.\n\nGSC = ProblemEvaluationLimitReached(10000)","category":"section"},{"location":"hms_config/#Local-stop-condition","page":"Configuration","title":"Local stop condition","text":"The Local Stop Condition (LSC) determines when an individual deme should stop its local search. This allows the HMS tree to dynamically reallocate resources by pruning stagnant demes and sprouting new ones in more promising areas.","category":"section"},{"location":"hms_config/#Available-Local-Stop-Conditions","page":"Configuration","title":"Available Local Stop Conditions","text":"The following conditions can be passed to the hms solver to control the demes:","category":"section"},{"location":"hms_config/#Default-LSC","page":"Configuration","title":"Default LSC","text":"The default LSC is set to MetaepochWithoutBestFitnessImprovement with 10 metaepochs  without improvement limit.\n\nDEFAULT_LSC = MetaepochWithoutBestFitnessImprovement(10)","category":"section"},{"location":"hms_config/#Sprout-condition","page":"Configuration","title":"Sprout condition","text":"Configurable parameter determining when a deme should sprout a child deme.\n\nHierarchicMemeticStrategy.jl provides sprout condition based on euclidean distance between demes.","category":"section"},{"location":"hms_config/#Default-Sprout-Condition","page":"Configuration","title":"Default Sprout Condition","text":"The default SC uses euclidean distance with default max distances calculated based on sigma parameter.\n\nfunction sprout_default_euclidean_distances(sigma::Vector{Vector{Float64}})\n    sprouting_condition_distance_ratio = 0.6\n    return [sum(s .* sprouting_condition_distance_ratio) for s in sigma]\nend\n\nconst DEFAULT_SC = function (sigma::Vector{Vector{Float64}})\n    return sc_max_metric(euclidean, sprout_default_euclidean_distances(sigma))   \nend","category":"section"},{"location":"hms_config/#Sigma","page":"Configuration","title":"Sigma","text":"Parameter for evolutionary algorithms and Gaussian mutation.  It is specified for each dimension at each level of the hms tree.","category":"section"},{"location":"hms_config/#Default-sigma","page":"Configuration","title":"Default sigma","text":"","category":"section"},{"location":"hms_config/#Population-sizes","page":"Configuration","title":"Population sizes","text":"Parameter specifies number of individuals in demes at each level.","category":"section"},{"location":"hms_config/#Create-population-function","page":"Configuration","title":"Create population function","text":"Configurable parameter that specifies how new populations are created.","category":"section"},{"location":"hms_config/#Default-create-population","page":"Configuration","title":"Default create population","text":"","category":"section"},{"location":"hms_config/#Local-optimizer","page":"Configuration","title":"Local optimizer","text":"Parameter sets local optimizer to perform search from best individuals at leaf demes  after global stop condition is satisfied. ","category":"section"},{"location":"hms_config/#Default-local-optimizer","page":"Configuration","title":"Default local optimizer","text":"Default local optimizer uses L-BFGS implementation from the Optim.jl package.","category":"section"},{"location":"hms_config/#HierarchicMemeticStrategy.hms","page":"Configuration","title":"HierarchicMemeticStrategy.hms","text":"hms(; kwargs...)\n\nExecute the Hierarchical Multi-Strategy (HMS) optimization algorithm.\n\nArguments\n\noptimization_problem::OptimizationProblem: The objective function and domain bounds.\nlevel_config::Vector{TreeLevelConfig}: Configuration for each level of the HMS tree (default: DEFAULT_LEVEL_CONFIG).\ntree_height::Int: Height of the HMS tree (default: length(level_config)).\nsigma::Vector{Vector{Float64}}: The $ \\sigma $ parameter for evolutionary algorithms and Gaussian mutation. It is specified for each dimension at each level of the hierarchy.\ngsc::GlobalStopCondition: Condition to stop the entire optimization process.\nlsc::LocalStopCondition: Condition to stop individual demes.\nsprout_condition::Function: Logic determining when a deme should sprout a child deme.\npopulation_sizes::Vector{Int}: Number of individuals in demes at each level.\ncreate_population::Function: Function used to initialize deme populations.\nlocal_optimizer::LocalOptimizer: The specific local optimizer to use (default LBFGSOptimizer).\nuse_local_method::Bool: Whether to apply a local optimization (default: true).\nminimize::Bool: Set to true to minimize, false to maximize (default: true).\nlog_level::Int: Verbosity of the output (0 for silent, 1 basic output, 2 basic string representation of hms tree).\nparallel::Bool: Enable multi-threaded execution (default: false).\nseed::Union{Nothing, Int}: Random seed for reproducibility.\n\nReturns\n\nHMSResult: An object containing the optimization trace, best solution, and visualization tools.\n\nExample\n\n# optimizing eggholder function\nfunction eggholder(x::Vector{Float64})\n    x1, x2 = x[1], x[2]\n    return -(x2 + 47) * sin(sqrt(abs(x2 + x1/2 + 47))) - x1 * sin(sqrt(abs(x1 - (x2 + 47))))\nend\n\nseed = 42\nlower = [-512.0, -512.0]\nupper = [512.0, 512.0]\nproblem = FunctionProblem(eggholder, lower, upper, false)\nsigma = [[100.0, 100.0], [60.0, 60.0]]\nlevel_config = [\n    TreeLevelConfig(EvolutionaryGAMetaepoch, Dict(\"seed\" => seed)),\n    TreeLevelConfig(EvolutionaryCMAESMetaepoch, Dict(\"seed\" => seed)),\n]\nresult = hms(\n    optimization_problem = problem,\n    level_config = level_config,\n    sigma=sigma,\n    seed=seed \n)\n\n\n\n\n\n","category":"function"},{"location":"hms_config/#HierarchicMemeticStrategy.TreeLevelConfig","page":"Configuration","title":"HierarchicMemeticStrategy.TreeLevelConfig","text":"TreeLevelConfig(metaepoch_type, options)\n\nConfiguration for a specific level in the HMS hierarchy.\n\nFields\n\nmetaepoch_type::Type{<:MetaepochRunner}: The evolutionary strategy or algorithm  to run at this level (e.g., EvolutionaryGAMetaepoch or EvolutionaryCMAESMetaepoch).\noptions::Dict{String, Any}: A dictionary of hyperparameters specific to the chosen  metaepoch_type (e.g. crossover rates, mutation).\n\nUsage\n\nEach level of the HMS tree can employ a different search strategy. By providing a  Vector{TreeLevelConfig} to the solver, you define how the search intensifies  from the root level down to the leaves.\n\nExample\n\nlevel_1 = TreeLevelConfig(EvolutionaryGAMetaepoch, Dict(\"crossoverRate\" => 0.3, \"mutationRate\" => 0.5))\n\n\n\n\n\n","category":"type"},{"location":"hms_config/#HierarchicMemeticStrategy.DEFAULT_LEVEL_CONFIG","page":"Configuration","title":"HierarchicMemeticStrategy.DEFAULT_LEVEL_CONFIG","text":"DEFAULTLEVELCONFIG\n\nThe default HMS tree structure used by the HMS solver if no custom configuration is provided.\n\nIt defines a 2-level tree:\n\nLevel 1: Uses EvolutionaryGAMetaepoch for broad exploration.\n\nLevel 2: Uses EvolutionaryCMAESMetaepoch for refined local search. \n\n\n\n\n\n","category":"constant"},{"location":"hms_config/#HierarchicMemeticStrategy.MetaepochRunner","page":"Configuration","title":"HierarchicMemeticStrategy.MetaepochRunner","text":"MetaepochRunner\n\nAn abstract type serving as the interface for all HMS search strategies.\n\nInterface\n\nAny subtype of MetaepochRunner must implement the run_metaepoch function with the following signature:\n\nrun_metaepoch(\n    runner::MetaepochRunner,\n    fitness_function::Function,\n    bounds::Bounds,\n    initial_population::Vector{Vector{Float64}},\n    minimize::Bool,\n    options::Dict{String, Any}\n)::MetaepochResult\n\n\n\n\n\n","category":"type"},{"location":"hms_config/#HierarchicMemeticStrategy.MetaepochResult","page":"Configuration","title":"HierarchicMemeticStrategy.MetaepochResult","text":"MetaepochResult(solution, best_fitness, populations, fitness_values, context)\n\nA data structure that captures the outcome and trace of a single metaepoch execution.\n\nFields\n\nsolution::Vector{Float64}: The best input vector found during this metaepoch.\nbest_fitness::Float64: The scalar fitness value associated with the solution.\npopulations::Vector{Vector{Vector{Float64}}}: A history of populations. \nfitness_values::Vector{Vector{Float64}}: A history of fitness scores. \n\nDescription\n\nThis object is returned by run_metaepoch and is used by the main HMS solver to  update the tree state, check stop conditions, and build the final result.\n\n\n\n\n\n","category":"type"},{"location":"hms_config/#HierarchicMemeticStrategy.EvolutionaryGAMetaepoch","page":"Configuration","title":"HierarchicMemeticStrategy.EvolutionaryGAMetaepoch","text":"EvolutionaryGAMetaepoch <: MetaepochRunner\n\nA metaepoch runner that utilizes a Genetic Algorithm (GA) implementation from the  Evolutionary.jl package.\n\nDescription\n\nThis runner performs a short burst of evolution on a deme's population. It is  typically used in the upper levels of the HMS tree for broad exploration of the  search space.\n\n\n\n\n\n","category":"type"},{"location":"hms_config/#HierarchicMemeticStrategy.run_metaepoch-Tuple{EvolutionaryGAMetaepoch, Function, Bounds, Vector{Vector{Float64}}, Bool, Dict{String, Any}}","page":"Configuration","title":"HierarchicMemeticStrategy.run_metaepoch","text":"run_metaepoch(::EvolutionaryGAMetaepoch, ...)\n\nExecute the Genetic Algorithm for a fixed number of iterations.\n\nSupported Options\n\nThe options::Dict{String, Any} parameter in TreeLevelConfig supports the  following keys when using EvolutionaryGAMetaepoch:\n\nKey Type Default Description\n\"iterations\" Int 3 Number of GA iterations to run.\n\"crossoverRate\" Float64 0.2 Probability of crossover.\n\"mutationRate\" Float64 0.8 Probability of mutation.\n\"epsilon\" Int 1 Number of best individuals to preserve (Elitism).\n\"crossover\" Function LC() Crossover operator (from Evolutionary.jl).\n\"mutation\" Function GaussianMutation Custom Gaussian mutation operator.\n\"sigma\" Vector fill(1.0, N) Standard deviation for the default Gaussian mutation.\n\"seed\" Int nothing Local RNG seed for reproducibility.\n\"show_trace\" Bool false Whether to print Evolutionary.jl progress to console.\n\nDetails\n\nThe fitness function is automatically transformed based on the minimize flag.  The population history is captured via a callback to ensure the MetaepochResult  trace is correctly populated.\n\n\n\n\n\n","category":"method"},{"location":"hms_config/#HierarchicMemeticStrategy.run_metaepoch-Tuple{EvolutionaryCMAESMetaepoch, Function, Bounds, Vector{Vector{Float64}}, Bool, Dict{String, Any}}","page":"Configuration","title":"HierarchicMemeticStrategy.run_metaepoch","text":"run_metaepoch(::EvolutionaryCMAESMetaepoch, ...)\n\nExecute the Covariance Matrix Adaptation Evolution Strategy (CMA-ES) from the Evolutionary.jl package.\n\nSupported Options\n\nThe options::Dict{String, Any} parameter in TreeLevelConfig supports the following keys when using EvolutionaryCMAESMetaepoch:\n\nKey Type Default Description\n\"iterations\" Int 3 Number of CMA-ES iterations to run.\n\"sigma0\" Float64 estimate_sigma0 Initial step size.\n\"seed\" Int nothing Local RNG seed for reproducibility.\n\"show_trace\" Bool false Whether to print Evolutionary.jl progress to the console.\n\nDetails\n\nThis method wraps the CMAES solver. It is particularly effective for  \"narrowing down\" on an optimum once the general area  has been found by a more exploratory algorithm like GA.\n\nThe population and fitness history are captured to populate the MetaepochResult trace.\n\n\n\n\n\n","category":"method"},{"location":"hms_config/#HierarchicMemeticStrategy.run_metaepoch-Tuple{EvolutionaryDEMetaepoch, Function, Bounds, Vector{Vector{Float64}}, Bool, Dict{String, Any}}","page":"Configuration","title":"HierarchicMemeticStrategy.run_metaepoch","text":"run_metaepoch(::EvolutionaryDEMetaepoch, ...)\n\nExecute the Differential Evolution (DE) algorithm implementation from the Evolutionary.jl package.\n\nSupported Options\n\nThe options::Dict{String, Any} parameter in TreeLevelConfig supports the following keys when using EvolutionaryDEMetaepoch:\n\nKey Type Default Description\n\"iterations\" Int 3 Number of DE iterations to run.\n\"F\" Float64 0.9 Scale factor (differential weight) for mutation.\n\"n\" Int 1 Number of differences used in the perturbation.\n\"selection\" Function random Selection strategy (e.g., random or best).\n\"recombination\" Function BINX(0.5) Recombination operator (e.g., BINX or EXP).\n\"K\" Float64 0.5*(F+1) Recombination constant.\n\"seed\" Int nothing Local RNG seed for reproducibility.\n\"show_trace\" Bool false Whether to print Evolutionary.jl progress to the console.\n\nDetails\n\nThis method wraps the DE solver from Evolutionary.jl.\n\n\n\n\n\n","category":"method"},{"location":"hms_config/#HierarchicMemeticStrategy.ProblemEvaluationLimitReached","page":"Configuration","title":"HierarchicMemeticStrategy.ProblemEvaluationLimitReached","text":"ProblemEvaluationLimitReached(limit::Int)\n\nA GlobalStopCondition that terminates the optimization once a specific number of  objective function evaluations has been reached.\n\nFields\n\nlimit::Int: The maximum allowed number of function evaluations (must be positive).\n\nDescription\n\nThis is the most common stopping criterion for the HMS algorithm. It monitors the  global evaluation counter and returns true as soon as the total evaluations  exceed the specified limit, ensuring the algorithm respects a predefined  computational budget.\n\nExample\n\n# Stop the algorithm after 10,000 function evaluations\ngsc = ProblemEvaluationLimitReached(10000)\n\n\n\n\n\n","category":"type"},{"location":"hms_config/#HierarchicMemeticStrategy.GlobalMetaepochLimitReached","page":"Configuration","title":"HierarchicMemeticStrategy.GlobalMetaepochLimitReached","text":"GlobalMetaepochLimitReached(limit::Int)\n\nA GlobalStopCondition that terminates the optimization after a fixed number of metaepochs.\n\nFields\n\nlimit::Int: The maximum number of metaepochs to perform (must be positive).\n\nDescription\n\nIn HMS metaepoch represents one full iteration of the algorithm where  every active deme in the tree is processed.\n\nExample\n\n# Stop the algorithm after 50 metaepochs of the HMS tree\ngsc = GlobalMetaepochLimitReached(50)\n\n\n\n\n\n","category":"type"},{"location":"hms_config/#HierarchicMemeticStrategy.LocalProblemEvaluationLimitReached","page":"Configuration","title":"HierarchicMemeticStrategy.LocalProblemEvaluationLimitReached","text":"LocalProblemEvaluationLimitReached(limit::Int)\n\nA LocalStopCondition that terminates a specific deme once it has performed a  certain number of objective function evaluations.\n\nFields\n\nlimit::Int: The maximum number of evaluations allowed for the specific deme.\n\nExample\n\n# Limit each leaf deme to 1000 evaluations\nlsc = LocalProblemEvaluationLimitReached(1000)\n\n\n\n\n\n","category":"type"},{"location":"hms_config/#HierarchicMemeticStrategy.AllChildrenStopped","page":"Configuration","title":"HierarchicMemeticStrategy.AllChildrenStopped","text":"AllChildrenStopped()\n\nA LocalStopCondition that triggers only when all children of the current deme  have reached their own stopping criteria.\n\n\n\n\n\n","category":"type"},{"location":"hms_config/#HierarchicMemeticStrategy.MetaepochWithoutBestFitnessImprovement","page":"Configuration","title":"HierarchicMemeticStrategy.MetaepochWithoutBestFitnessImprovement","text":"MetaepochWithoutBestFitnessImprovement(n_metaepochs::Int)\n\nA LocalStopCondition that triggers if the best fitness within a deme fails to  improve for a specified number of consecutive metaepochs.\n\nFields\n\nn_metaepochs::Int: The threshold of consecutive stagnant metaepochs allowed before stopping.\n\nDescription\n\nThis condition is used to prune demes that have reached a local optimum or are  stuck in a plateau.\n\nExample\n\n# Stop a deme if it doesn't improve for 5 consecutive metaepochs\nlsc = MetaepochWithoutBestFitnessImprovement(5)\n\n\n\n\n\n","category":"type"},{"location":"hms_config/#HierarchicMemeticStrategy.sc_max_metric","page":"Configuration","title":"HierarchicMemeticStrategy.sc_max_metric","text":"sc_max_metric(metric::Function, max_distances::Vector{Float64})\n\nCreate a sprouting condition that ensures a new deme is sufficiently far from existing demes at the same level.\n\nArguments\n\nmetric::Function: A distance function, e.g., dist(a, b), used to calculate the separation between points.\nmax_distances::Vector{Float64}: A vector where max_distances[i] defines the minimum required distance for level i + 1.\n\nReturns\n\nA function (potential_sprout, potential_sprout_level, demes) -> Bool that returns true if the potential sprout location is valid.\n\nDescription\n\nIf the distance to any existing deme at that level is less than the threshold defined in max_distances, the condition returns false, and the sprout is suppressed. This mechanism is critical for:\n\nDiversity: Preventing multiple demes from converging on the same local optimum.\nExploration: Forcing the algorithm to seek out new, unexplored regions of the search space.\n\nExample\n\n# Use Euclidean distance with a 2.0 threshold for level 2 and 0.5 for level 3\neuclidean(a::Vector{Float64}, b::Vector{Float64}) = sqrt(sum((a .- b).^2))\nsprout_cond = sc_max_metric(euclidean, [2.0, 0.5])\n\n\n\n\n\n","category":"function"},{"location":"hms_config/#HierarchicMemeticStrategy.default_sigma","page":"Configuration","title":"HierarchicMemeticStrategy.default_sigma","text":"default_sigma(lower::Vector{Float64}, upper::Vector{Float64}, tree_height::Int)\n\nGenerate sigma parameter for each level of the HMS tree.\n\nArguments\n\nlower::Vector{Float64}: Lower bounds of the search space.\nupper::Vector{Float64}: Upper bounds of the search space.\ntree_height::Int: Total number of levels in the HMS hierarchy.\n\nReturns\n\nVector{Vector{Float64}}: A list of sigma vectors, one for each level, where values decrease geometrically as the tree gets deeper.\n\nDescription\n\nSigma value is a fraction of the total domain length (upper - lower). This function  applies a geometric decay:\n\nRoot Level: Starts at 4% of the domain length (sigma_ratio = 0.04).\nSubsequent Levels: Each level's sigma is reduced by 50% (sigma_exponent = 0.5) compared to the level above.\n\nThis ensures that top-level demes perform broad global exploration, while lower-level demes focus on increasingly fine-grained local exploitation.\n\n\n\n\n\n","category":"function"},{"location":"hms_config/#HierarchicMemeticStrategy.default_population_sizes","page":"Configuration","title":"HierarchicMemeticStrategy.default_population_sizes","text":"default_population_sizes(tree_height::Int)\n\nGenerate set of population sizes for each level of the HMS tree.\n\nArguments\n\ntree_height::Int: Total number of levels in the HMS hierarchy.\n\nReturns\n\nVector{Int}: A vector of population sizes, one for each level, decreasing as the tree gets deeper.\n\nDescription\n\nIn a Hierarchical Multi-Strategy search, it is often beneficial to have larger populations  at the root level to maintain diversity and smaller populations at lower levels for  specialized local search. This function implements a geometric decay:\n\nRoot Level: Starts with a population of 60.\nDecay: Each subsequent level's population is reduced by 50%.\n\nExample\n\nsizes = default_population_sizes(4)\n# Returns: [60, 30, 15, 8]\n\n\n\n\n\n","category":"function"},{"location":"hms_config/#HierarchicMemeticStrategy.default_create_population","page":"Configuration","title":"HierarchicMemeticStrategy.default_create_population","text":"default_create_population(sigma::Vector{Vector{Float64}}, rng::AbstractRNG = Random.default_rng())\n\nCreate a population initialization that chooses between uniform and normal distributions based on tree level.\n\nArguments\n\nsigma::Vector{Vector{Float64}}: A vector of step-size vectors for each level (e.g., from default_sigma).\nrng::AbstractRNG: An optional random number generator for reproducibility.\n\nReturns\n\nA function (mean, lower, upper, population_size, tree_level, sigma, rng) -> Vector{Vector{Float64}}.\n\nDescription\n\nThe returned function handles two distinct initialization strategies:\n\nRoot Level (Level 1): Uses uniform distribution. This ensures the initial search covers the entire search space defined by lower and upper.\nSubsequent Levels (Level > 1): Uses uses normal distribution centered around the mean (new deme). The spread is controlled by the sigma corresponding to tree level.\n\nThis approach is fundamental to HMS: the root explores globally, while children refine locally.\n\n\n\n\n\n","category":"function"},{"location":"hms_config/#HierarchicMemeticStrategy.LocalOptimizer","page":"Configuration","title":"HierarchicMemeticStrategy.LocalOptimizer","text":"LocalOptimizer\n\nAn abstract type for all local refinement strategies in the HMS algorithm.\n\nDescription\n\nLocalOptimizer is used to perform fine-grained refinement on the  best individual of a leaf demes after global stop condition is satisfied.\n\nInterface\n\nAny subtype must implement: optimize!(optimizer::LocalOptimizer, deme::Deme, cached_f::CustomCache)\n\n\n\n\n\n","category":"type"},{"location":"#HierarchicMemeticStrategy.jl","page":"Home","title":"HierarchicMemeticStrategy.jl","text":"The package HierarchicMemeticStrategy.jl provides an implementation of the Hierarchic Memetic Strategy (HMS) â€” a population-based, multi-level metaheuristic for global optimization that combines evolutionary search with local optimization and hierarchical population management.\n\nHMS organizes the search process into a tree of demes, where each level applies increasingly focused optimization strategies, enabling efficient exploration and exploitation of complex, multimodal objective functions.","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"To install the package, use:\n\n] add HierarchicMemeticStrategy\n\nExample of using the HMS algorithm to find minimum of the Rosenbrock function in 2 dimension version.\n\nusing HierarchicMemeticStrategy\n\nrosenbrock(x) = (1 - x[1])^2 + (100 * (x[2] - x[1]^2)^2)\n\nproblem = FunctionProblem(\n    rosenbrock,\n    [-30.0, -30.0],\n    [30.0, 30.0],\n    false\n)\n\nresult = hms(optimization_problem = problem)","category":"section"},{"location":"tutorial/#Optimization","page":"Tutorial","title":"Optimization","text":"To demonstrate the package's capabilities, let's apply it to the Rosenbrock function, a well-known benchmark in numerical optimization","category":"section"},{"location":"tutorial/#Defining-a-Problem","page":"Tutorial","title":"Defining a Problem","text":"To optimize a function using HierarchicMemeticStrategy.jl, you must encapsulate your objective function and its constraints within a FunctionProblem object.\n\nFirst define the Rosenbrock function:\n\nusing HierarchicMemeticStrategy\nrosenbrock(x) = (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2;\n\nNext, wrap it in a FunctionProblem object, specifying the bounds for each variable and whether to maximize or minimize:\n\nlower_bounds = [-5.0, -5.0];\nupper_bounds = [5.0, 5.0];\n\nproblem = FunctionProblem(\n    fitness_function = rosenbrock,\n    lower = lower_bounds,\n    upper = upper_bounds,\n    maximize = false\n);","category":"section"},{"location":"tutorial/#Performing-Optimization","page":"Tutorial","title":"Performing Optimization","text":"Once Function Problem is defined, we can perform optimization using hms algorithm.\n\nres = hms(optimization_problem=problem)","category":"section"},{"location":"tutorial/#Configuration","page":"Tutorial","title":"Configuration","text":"The example above uses default configuration. For more configuration details  check HMS Configuration section.","category":"section"},{"location":"tutorial/#Obtaining-Results","page":"Tutorial","title":"Obtaining Results","text":"Once the optimization process is complete, the solver returns an HMSResult object. This object contains the full history of the run, the best found solution, and tools for visualization.","category":"section"},{"location":"tutorial/#List-of-functions","page":"Tutorial","title":"List of functions","text":"HMSResult interface for optimization result.","category":"section"},{"location":"tutorial/#HierarchicMemeticStrategy.FunctionProblem","page":"Tutorial","title":"HierarchicMemeticStrategy.FunctionProblem","text":"FunctionProblem(; fitness_function, lower, upper, maximize=false)\n\nConstruct an optimization problem for a standard mathematical function.\n\nArguments\n\nfitness_function::Function: The objective function to evaluate. It must accept a  single vector x and return a scalar numerical value.\nlower::Vector: A vector specifying the minimum allowable values for each dimension.\nupper::Vector: A vector specifying the maximum allowable values for each dimension.\nmaximize::Bool: (Optional) Set to true for maximization, or false for  minimization (default).\n\nExamples\n\nproblem = FunctionProblem(\n    fitness_function = x -> x[1]^2 + x[2]^2,\n    lower = [-5.0, -5.0],\n    upper = [5.0, 5.0]\n)\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#HierarchicMemeticStrategy.HMSResult","page":"Tutorial","title":"HierarchicMemeticStrategy.HMSResult","text":"HMSResult\n\nA structure containing the results of an HMS optimization run.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#HierarchicMemeticStrategy.summary-Tuple{HMSResult}","page":"Tutorial","title":"HierarchicMemeticStrategy.summary","text":"summary(result::HMSResult)\n\nPrint a formatted summary table to the standard output for a quick overview of the results.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#HierarchicMemeticStrategy.solution-Tuple{HMSResult}","page":"Tutorial","title":"HierarchicMemeticStrategy.solution","text":"solution(result::HMSResult)\n\nReturn the best-found input vector (solution).\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#HierarchicMemeticStrategy.best_fitness-Tuple{HMSResult}","page":"Tutorial","title":"HierarchicMemeticStrategy.best_fitness","text":"best_fitness(result::HMSResult)\n\nReturns the scalar fitness value at the best-found point.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#HierarchicMemeticStrategy.iterations-Tuple{HMSResult}","page":"Tutorial","title":"HierarchicMemeticStrategy.iterations","text":"iterations(result::HMSResult)\n\nReturn the total count of metaepochs performed during the run.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#HierarchicMemeticStrategy.f_calls-Tuple{HMSResult}","page":"Tutorial","title":"HierarchicMemeticStrategy.f_calls","text":"f_calls(result::HMSResult)\n\nReturn the total number of times the objective function was evaluated across all demes.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#HierarchicMemeticStrategy.metaepoch_data-Tuple{HMSResult}","page":"Tutorial","title":"HierarchicMemeticStrategy.metaepoch_data","text":"metaepoch_data(result::HMSResult)\n\nReturn algorithm data.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#HierarchicMemeticStrategy.plotPopulations-Tuple{HMSResult, Int64, Int64}","page":"Tutorial","title":"HierarchicMemeticStrategy.plotPopulations","text":"plotPopulations(result::HMSResult)\n\nShow interactive plot presenting changes in populations during metaepochs.\n\nArguments\n\nresult::HMSResult: The result object returned by the optimizer.\nx_index::Int: The index of the dimension to plot on the x-axis (default: 1).\ny_index::Int: The index of the dimension to plot on the y-axis (default: 2).\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#HierarchicMemeticStrategy.plotBestFitness-Tuple{HMSResult}","page":"Tutorial","title":"HierarchicMemeticStrategy.plotBestFitness","text":"plotBestFitness(result::HMSResult)\n\nPlot best_fitness value during metaepochs.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#HierarchicMemeticStrategy.plotDeme-Tuple{HMSResult, Int64, Int64, Int64}","page":"Tutorial","title":"HierarchicMemeticStrategy.plotDeme","text":" plotDeme(result::HMSResult)\n\nPlot single Deme population over metaepochs.\n\nArguments\n\nresult::HMSResult: The result object returned by the HMS optimizer.\ndeme_index::Int: The index of deme to visualize (default: 1).\nx_index::Int: The index of the dimension to plot on the x-axis (default: 1).\ny_index::Int: The index of the dimension to plot on the y-axis (default: 2).\n\n\n\n\n\n","category":"method"}]
}
